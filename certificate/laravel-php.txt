Why Laravel:
Elegant and expressive syntax
Simplification to allow focus on development and removing biolerplate
Provides pre-built components, libs and tools to avoid starting from scratch
Provides routing, auth, caching, session

Advantages:
MVC (Model-View-Controller) arch, promoting seperation of concerns for scalablity and mantainablity reasons
Large ecosystem of extensions (Laravel Packages/Bundles)
Vibrant community
Modern tooling (Eloquent ORM, Blade templates, Artisan CLI, testing utilities)

MVC Arch:
<Figure>

Model:
Data & Buisness logic
--
DB interaction, data access, data manip, data validation
Classes/Models: DB Tables (CRUD, Buisness rules)

View:
Data presentation (HTML/CSS/JS for UI)
--
Plain PHP/Blade templates (Dynamic, reusable)

Controller:
Intermediate between Model & View
Handles user requests, porcesses inputs
--
Responsible for HTTP requests

Significance in Laravel:
Separation of Concerns: MVC promotes a clear separation of concerns. Models handle data manipulation, Views handle presentation logic, and Controllers manage the application flow. This separation enhances code organization, readability, and maintainability.
Code Reusability: Each component in MVC can be developed independently. Views can be reused with different Controllers, and Models can be used across various application parts. This reusability reduces duplication and enhances efficiency.
Scalability and Maintainability: By separating components based on their roles, MVC makes applications easier to maintain and scale. Changes in one component (e.g., updating the database schema in the Model) don't directly impact other components.
Supports Testing: The separation of concerns facilitates unit testing. Developers can independently test Models, Views, and Controllers, ensuring each component functions correctly.

Example:
Model:
namespace App;
use Illuminate\Database\Eloquent\Model;

class User extends Model
{
      public function posts() {
            return $this->hasMany(Post::class);
      }
}
View:
<!-- resources/views/users/show.blade.php -->
<h1>User Profile</h1>
<p>Name: {{ $user->name }}</p>
<p>Email: {{ $user->email }}</p>
Controller:
namespace App\Http\Controllers;
use App\User; use Illuminate\Http\Request;

class UserController extends Controller
{
      public function show($id) {
            $user = User::find($id);
            return view('users.show', ['user' => $user]);
      }
}

Setup:
Using composer: composer create-project --prefer-dist laravel/laravel laravel-project
Application Key:
Generate: php artisan key:generate
Used for encrypt/decrypt, hash, sign
Serve-dev: php artisan serve

Directory Structure:
app: This directory is the heart of your application. It contains folders like:
    - Console: Contains artisan commands.
    - Exceptions: Manages exception handling.
    - Http: Contains controllers, middleware, form requests, and route definitions.
    - Models: Houses your application's data models.
    - Providers: Manages service providers.
bootstrap: This directory holds the files responsible for bootstrapping the Laravel application and loading the necessary components.
config: Contains configuration files for different parts of your application, such as database connections, cache settings, and more.
database: Houses the database-related files:
    - migrations: Contains database schema changes using migration files.
    - seeds: Holds seed files to populate the database with test data.
public: The entry point of your application. This folder contains the index.php file and publicly accessible assets like CSS, JavaScript, and images.
resources: This directory stores non-PHP resources like views, language files, and frontend assets:
views: Contains the Blade templates for your application's UI.lang: Holds language files for internationalization.
routes: Contains route definitions for your application, organizing how HTTP requests should be handled.
storage: Holds temporary files generated by your application, including logs, cache, and session files.
tests: Contains test cases for your application.
vendor: This directory holds Composer dependencies, including the Laravel framework itself and other libraries/packages used in your project.

app:
Console: Contains artisan commands and console-based functionality.
Exceptions: Houses custom exception classes.
Http: Contains the controllers, middleware, and form requests for handling HTTP requests.
Jobs: Stores queued job classes.
Listeners: Holds event listener classes for handling events and broadcasting.
Mail: Contains classes responsible for building and sending emails.
Models: The home for Eloquent model classes that represent database tables.
Notifications: Contains classes for defining notification messages.
Policies: Holds policy classes for handling authorization.
Providers: Contains service providers that bootstrap and configure various aspects of the application.
Rules: Stores custom validation rule classes.
Traits: A place for reusable traits that can be applied to multiple classes.

Summary:
Laravel offers a streamlined development process, allowing developers to build modern, feature-rich web applications with ease.
Artisan, Laravel's command-line tool, simplifies common development tasks, such as project setup, database migrations, and testing.
Eloquent ORM facilitates database interaction by providing an intuitive syntax for managing database records and relationships.
Laravel's Blade templating engine offers a powerful and expressive way to create dynamic and reusable views.
The framework embraces conventions and best practices, promoting clean and maintainable code.
Laravel follows the MVC architectural pattern, dividing the application into three interconnected components: 
- Model: Represents the application's data structures and business logic, interacting with the database.
- View: Handles the presentation and display of data to the user, often using Laravel's Blade templating engine for dynamic content.
- Controller: Acts as an intermediary between the model and view, receiving user input, processing it, and determining the appropriate response.
- MVC promotes code organization, separation of concerns, and maintainability, making it easier for developers to collaborate and maintain codebases.
- The lesson covered the step-by-step process of initializing a Laravel project using Composer and Laravel's command-line tool, Artisan.
- By running composer create-project laravel/laravel project-name, developers can quickly set up a new Laravel project, complete with the necessary directory structure and dependencies.
- We explored the contents of the artisan file and its role in executing various commands for project management.
- Additionally, the lesson touched upon essential configuration files, such as .env, for environment-specific settings.

Active Record Introduction
Active Record is a design pattern that provides an object-oriented interface for accessing and manipulating data stored in a database. This pattern encapsulates the business logic of an application within the model, allowing developers to interact with the database using a simple and intuitive API. Laravel's Eloquent ORM (Object-Relational Mapping) is an implementation of the Active Record pattern.
Model Representation
In Active Record, a model class represents a table in the database. Each instance of the model class corresponds to a record in the table.
CRUD Operations
Active Record simplifies database interactions by providing methods for Create, Read, Update, and Delete operations. Models typically have methods like create, find, update, and delete for these operations.
Relationships
Active Record simplifies handling relationships between tables. Eloquent models define relationships such as one-to-one, one-to-many, and many-to-many using methods like hasOne, hasMany, belongsTo, etc.
Validation
Active Record models often include validation rules. Laravel's Eloquent allows you to define validation rules for model attributes.

Migrations:
Create: php artisan make:migration create_users_table
Apply: php artisan migrate

In the Laravel, Eloquent Models stand as the backbone of database interaction, providing an elegant and expressive way to interact with databases. Eloquent Models serve as an abstraction layer between your application and the database. They represent tables in your database, allowing you to interact with the data in a highly intuitive and object-oriented manner. With Eloquent, the tedious tasks of writing raw SQL queries and managing database connections are replaced with a clean, expressive syntax.
Eloquent Models are typically placed in the app/Models directory by convention. However, it's important to note that you are not strictly required to follow this convention, and you can customize the location if needed.
Create Model: php artisan make:model YourModel

Views in Laravel serve as the user interface components of your web application. They allow you to organize and display information to the user. Blade, Laravel's templating engine, makes the process of creating these views both efficient and clear. Blade files typically have a .blade.php extension, and they are stored in the resources/views directory. The template can be used in the controller by view helper.

Blade comes with convenient directives for control structures, making it easy to implement logic in your views. There are some popular directives: @section, @show, @yield, @extends, @include, @for, @foreach, @if, @else.
Example:
@extends('layouts.app')
@section('content') <p>This is the content of the child view.</p> @endsection
@foreach($users as $user) <p>{{ $user->name }}</p> @endforeach
@if($condition) 
    <p>Condition is true.</p> 
@elseif($anotherCondition) 
    <p>Another condition is true.</p> 
@else 
    <p>Neither condition is true.</p> 
@endif

In the context of the Laravel PHP framework, a controller is a class that handles the incoming HTTP requests and manages the application's logic to produce an appropriate HTTP response. Controllers act as an intermediary between the model (which represents the data and business logic) and the view (which displays the user interface). 
Method 1: Using Artisan Command
To create a new controller using the Artisan command-line tool, open your terminal and navigate to your Laravel project's root directory. Then, run the following command:
> php artisan make:controller UserController
Replace "UserController" with the desired name for your controller. This command will create a new controller file in the app/Http/Controllers directory.
Method 2: Manual Creation
Create a new PHP file in the app/Http/Controllers directory. For example, you can create UserController.php.
<?php
 namespace App\Http\Controllers;
 use Illuminate\Http\Request;

 class UserController extends Controller {}

Routing Introduction
In Laravel, routes are defined in the routes/web.php file for web routes and routes/api.php for API routes. The basic syntax for defining a route looks like this:
Route::get('/example', function () { return 'Hello, this is an example route!'; });
This example defines a route for the HTTP GET method that maps to the /example URI, and when accessed, it returns a simple string.
Instead of using closures, you can define routes that point to controller methods, promoting better code organization:
Route::get('/user/{id}', 'UserController@show'); // let's call 'show' action

Using Named Routes
We can use name() method for adding a particular name for our route. 
Route::get('/users', 'UsersController@list')->name('users');
Then, we can use the defined name to refer to this route from different places.

Show the named route as the URL in the view template:
<a href="{{ route('users') }}">Go to Users Page</a>
Also, you can use your named route in the controller. After fulfilling some operation in the action, we can redirect the user to the "users" route:
public function update() {
    // performing some update operations and then
    return redirect()->route('users');
}

Lesson Summary
The main points covered in the module are:
Controllers act as intermediaries between the user interface and the application logic. They receive input from the user, process it, and return an appropriate response.
We explored how to create controllers using Laravel's artisan command-line tool, enabling us to structure the application's logic in a clean and organized manner.
Additionally, we learned about the concept of resource controllers, which streamline the creation of CRUD (Create, Read, Update, Delete) operations.
Laravel's routing system defines how the application responds to HTTP requests. Routes specify which controller method should handle a particular request.
We discussed the creation of routes in Laravel, both basic routes and resourceful routes. Resourceful routes are particularly beneficial for handling CRUD operations seamlessly.
Route parameters and naming conventions were also covered, allowing for dynamic and customizable routes.
Models represent the data structures in the application and interact with the database. They encapsulate the business logic related to data manipulation.
Laravel's Eloquent ORM (Object-Relational Mapping) simplifies database interactions by providing an expressive syntax for querying and modifying database records.
We explored the process of creating models, defining relationships between models, and using Eloquent to perform common database operations.
Views are responsible for presenting the application's data to the user. They define the structure and layout of the user interface.
Blade, Laravel's templating engine, facilitates the creation of dynamic and reusable views. We discussed the basics of Blade syntax, including directives and control structures.
The lesson covered integrating views with controllers, enabling data passing from controllers to views for dynamic content rendering.
